/*
 *                   GNU GENERAL PUBLIC LICENSE
 *                      Version 3, 29 June 2007
 *
 * Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 * Everyone is permitted to copy and distribute verbatim copies
 * of this license document, but changing it is not allowed.
 * 
 * A complete copy of the license is attached to this library.
 */

#include <iLabs_Bi2C_KBD.h>

void Bi2C_KBD::i2cWriteReg(uint8_t reg, uint8_t data) {
  Wire.beginTransmission(_address);
  Wire.write((uint8_t)reg);
  Wire.write((uint8_t)data);
  Wire.endTransmission(true);
}

uint8_t Bi2C_KBD::i2cReadReg(uint8_t reg) {
  Wire.beginTransmission(_address);
  Wire.write((uint8_t)reg);
  Wire.endTransmission(true);

  Wire.requestFrom(_address, 1);
  return (Wire.read());
}

/*
 * Wrapper for the control register that holds a local shadow copy.
 */
void Bi2C_KBD::writeCtrlReg(uint8_t data) {
    i2cWriteReg(CTRL_REG_W, data);
    _ctrl_reg = data;
}

/*
 * Wrapper for the control register that holds a local shadow copy.
 */
uint8_t Bi2C_KBD::readCtrlReg() {
    return _ctrl_reg;
}

/*
 * Dummy interrupt function during reset.
 */
static void grabbed_int() {
}

void Bi2C_KBD::begin(uint8_t address, int intpin, void (*intcb)()) {
    _address = address;
    _intpin = intpin;
    _intcb = intcb;
    _ctrl_reg = 0;

    if (_intpin != -1) {
        writeCtrlReg(0x05);  // Enable interrupts, external pullup
        delay(10);
        attachInterrupt(digitalPinToInterrupt(_intpin), _intcb, FALLING);
    }
}

/*
 * Reset the keyboard controller.
 */
void Bi2C_KBD::reset() {
    if (_intpin != DONT_USE_INT) {
        // Temporary grab the interrupt to catch any erronous interrupts
        // that are being generated by the chip resetting.
        detachInterrupt(digitalPinToInterrupt(_intpin));
        attachInterrupt(digitalPinToInterrupt(_intpin), grabbed_int, CHANGE);
    }

    i2cWriteReg(CTRL_REG_W, 0x80);      // Write reset command to keyboard
    delay(25);

    begin(_address, _intpin, _intcb);
}

/*
 * Disable the numeric keys on the keyboard.
 * This is useful if you only want feedback from the alpha numeric keys.
 * The input flag should be set to true if you want to disable the keys
 * and false if you want to enable them again.
 */
void Bi2C_KBD::disableNumKeys(bool disable) {
    if (disable) {
        writeCtrlReg(readCtrlReg() | CTRL_REG_NUM_KEYS_DISABLE);
    } else {
        writeCtrlReg(readCtrlReg() & ~CTRL_REG_NUM_KEYS_DISABLE);
    }
}

/*
 * Disable the alpha numeric keys on the keyboard.
 * This is useful if you only want feedback from the numeric keys.
 * The input flag should be set to true if you want to disable the keys
 * and false if you want to enable them again.
 */
void Bi2C_KBD::disableAlphaKeys(bool disable) {
    if (disable) {
        writeCtrlReg(readCtrlReg() | CTRL_REG_ALPHA_KEYS_DISABLE);
    } else {
        writeCtrlReg(readCtrlReg() & ~CTRL_REG_ALPHA_KEYS_DISABLE);
    }
}

/*
 * Read one character from the keyboard buffer.
 */
uint8_t Bi2C_KBD::read() {
    return i2cReadReg(KEY_REG_R);
}

/*
 * Return how many characters that are currently in the keyboard buffer
 */
size_t Bi2C_KBD::available() {
    return i2cReadReg(NUM_KEYS_REG_R);
}

/*
 * Flush keyboard buffer
 */
void Bi2C_KBD::flush() {
    while (available())
        read();
}

/*
 * Set a LED mode on the selected LED.
 * LED's range from 1 (The status LED) to 5 (2-5 are the indicator LED's)
 * besides the alphanumeric keys (A-D).
 */
bool Bi2C_KBD::setLEDMode(uint32_t led, uint8_t mode) {
    uint8_t rmode;
    if (led > NUM_LEDS)
        return false;
    if (mode >= LED_MODE_END)
        return false;

    switch (led) {
        case STATUS_LED:
            i2cWriteReg(LED_CTRL_REG_1_W, mode);
            break;

        case INDICATOR_LED_A:
            rmode = i2cReadReg(LED_CTRL_REG_2_W);
            i2cWriteReg(LED_CTRL_REG_2_W, (rmode & 0xf0) | mode);
            break;

        case INDICATOR_LED_B:
            rmode = i2cReadReg(LED_CTRL_REG_2_W);
            i2cWriteReg(LED_CTRL_REG_2_W, (rmode & 0x0f) | (mode << 4));
            break;

        case INDICATOR_LED_C:
            rmode = i2cReadReg(LED_CTRL_REG_3_W);
            i2cWriteReg(LED_CTRL_REG_3_W, (rmode & 0xf0) | mode);
            break;

        case INDICATOR_LED_D:
            rmode = i2cReadReg(LED_CTRL_REG_3_W);
            i2cWriteReg(LED_CTRL_REG_3_W, (rmode & 0x0f) | (mode << 4));
            break;
    }
    return true;
}

/*
 * Returns the LED mode of the selected LED
 * LED's range from 1 (The status LED) to 5 (2-5 are the indicator LED's)
 * besides the alphanumeric keys (A-D).
 */
uint8_t Bi2C_KBD::getLEDMode(uint32_t led) {
    uint8_t rmode;

    if (led > NUM_LEDS)
        return false;

    switch (led) {
        case STATUS_LED:
            rmode = i2cReadReg(LED_CTRL_REG_1_W);
            break;

        case INDICATOR_LED_A:
            rmode = i2cReadReg(LED_CTRL_REG_2_W) & 0x0f;
            break;

        case INDICATOR_LED_B:
            rmode = (i2cReadReg(LED_CTRL_REG_2_W) >> 4) & 0x0f;
            break;

        case INDICATOR_LED_C:
            rmode = i2cReadReg(LED_CTRL_REG_3_W) & 0x0f;
            break;

        case INDICATOR_LED_D:
            rmode = (i2cReadReg(LED_CTRL_REG_3_W) >> 4) & 0x0f;
            break;
    }
    return rmode;
}

Bi2C_KBD bi2c_kbd;